// Code generated by goa v3.11.0, DO NOT EDIT.
//
// tokenManager HTTP client types
//
// Command:
// $ goa gen admin-panel/design

package client

import (
	tokenmanager "admin-panel/gen/token_manager"

	goa "goa.design/goa/v3/pkg"
)

// TokenCreateRequestBody is the type of the "tokenManager" service
// "tokenCreate" endpoint HTTP request body.
type TokenCreateRequestBody struct {
	ID      *string `form:"_id,omitempty" json:"_id,omitempty" xml:"_id,omitempty"`
	TokenID *string `form:"tokenId,omitempty" json:"tokenId,omitempty" xml:"tokenId,omitempty"`
	// chain id
	ChainID int64 `form:"chainId" json:"chainId" xml:"chainId"`
	// token address
	Address string `form:"address" json:"address" xml:"address"`
	// name in token contract
	TokenName *string `form:"tokenName,omitempty" json:"tokenName,omitempty" xml:"tokenName,omitempty"`
	// corresponding name in cex
	MarketName string  `form:"marketName" json:"marketName" xml:"marketName"`
	Precision  int64   `form:"precision" json:"precision" xml:"precision"`
	ChainType  *string `form:"chainType,omitempty" json:"chainType,omitempty" xml:"chainType,omitempty"`
	CoinType   string  `form:"coinType" json:"coinType" xml:"coinType"`
}

// TokenDeleteRequestBody is the type of the "tokenManager" service
// "tokenDelete" endpoint HTTP request body.
type TokenDeleteRequestBody struct {
	// mongodb primary key
	ID string `form:"_id" json:"_id" xml:"_id"`
}

// TokenListResponseBody is the type of the "tokenManager" service "tokenList"
// endpoint HTTP response body.
type TokenListResponseBody struct {
	Code *int64 `form:"code,omitempty" json:"code,omitempty" xml:"code,omitempty"`
	// list
	Result  []*TokenItemResponseBody `form:"result,omitempty" json:"result,omitempty" xml:"result,omitempty"`
	Message *string                  `form:"message,omitempty" json:"message,omitempty" xml:"message,omitempty"`
}

// TokenCreateResponseBody is the type of the "tokenManager" service
// "tokenCreate" endpoint HTTP response body.
type TokenCreateResponseBody struct {
	Code    *int64  `form:"code,omitempty" json:"code,omitempty" xml:"code,omitempty"`
	Result  *int64  `form:"result,omitempty" json:"result,omitempty" xml:"result,omitempty"`
	Message *string `form:"message,omitempty" json:"message,omitempty" xml:"message,omitempty"`
}

// TokenDeleteResponseBody is the type of the "tokenManager" service
// "tokenDelete" endpoint HTTP response body.
type TokenDeleteResponseBody struct {
	Code    *int64  `form:"code,omitempty" json:"code,omitempty" xml:"code,omitempty"`
	Result  *int64  `form:"result,omitempty" json:"result,omitempty" xml:"result,omitempty"`
	Message *string `form:"message,omitempty" json:"message,omitempty" xml:"message,omitempty"`
}

// TokenItemResponseBody is used to define fields on response body types.
type TokenItemResponseBody struct {
	ID      *string `form:"_id,omitempty" json:"_id,omitempty" xml:"_id,omitempty"`
	TokenID *string `form:"tokenId,omitempty" json:"tokenId,omitempty" xml:"tokenId,omitempty"`
	// chain id
	ChainID *int64 `form:"chainId,omitempty" json:"chainId,omitempty" xml:"chainId,omitempty"`
	// token address
	Address *string `form:"address,omitempty" json:"address,omitempty" xml:"address,omitempty"`
	// name in token contract
	TokenName *string `form:"tokenName,omitempty" json:"tokenName,omitempty" xml:"tokenName,omitempty"`
	// corresponding name in cex
	MarketName *string `form:"marketName,omitempty" json:"marketName,omitempty" xml:"marketName,omitempty"`
	Precision  *int64  `form:"precision,omitempty" json:"precision,omitempty" xml:"precision,omitempty"`
	ChainType  *string `form:"chainType,omitempty" json:"chainType,omitempty" xml:"chainType,omitempty"`
	CoinType   *string `form:"coinType,omitempty" json:"coinType,omitempty" xml:"coinType,omitempty"`
}

// NewTokenCreateRequestBody builds the HTTP request body from the payload of
// the "tokenCreate" endpoint of the "tokenManager" service.
func NewTokenCreateRequestBody(p *tokenmanager.TokenItem) *TokenCreateRequestBody {
	body := &TokenCreateRequestBody{
		ID:         p.ID,
		TokenID:    p.TokenID,
		ChainID:    p.ChainID,
		Address:    p.Address,
		TokenName:  p.TokenName,
		MarketName: p.MarketName,
		Precision:  p.Precision,
		ChainType:  p.ChainType,
		CoinType:   p.CoinType,
	}
	return body
}

// NewTokenDeleteRequestBody builds the HTTP request body from the payload of
// the "tokenDelete" endpoint of the "tokenManager" service.
func NewTokenDeleteRequestBody(p *tokenmanager.DeleteTokenFilter) *TokenDeleteRequestBody {
	body := &TokenDeleteRequestBody{
		ID: p.ID,
	}
	return body
}

// NewTokenListResultOK builds a "tokenManager" service "tokenList" endpoint
// result from a HTTP "OK" response.
func NewTokenListResultOK(body *TokenListResponseBody) *tokenmanager.TokenListResult {
	v := &tokenmanager.TokenListResult{
		Code:    body.Code,
		Message: body.Message,
	}
	if body.Result != nil {
		v.Result = make([]*tokenmanager.TokenItem, len(body.Result))
		for i, val := range body.Result {
			v.Result[i] = unmarshalTokenItemResponseBodyToTokenmanagerTokenItem(val)
		}
	}

	return v
}

// NewTokenCreateResultOK builds a "tokenManager" service "tokenCreate"
// endpoint result from a HTTP "OK" response.
func NewTokenCreateResultOK(body *TokenCreateResponseBody) *tokenmanager.TokenCreateResult {
	v := &tokenmanager.TokenCreateResult{
		Code:    body.Code,
		Result:  body.Result,
		Message: body.Message,
	}

	return v
}

// NewTokenDeleteResultOK builds a "tokenManager" service "tokenDelete"
// endpoint result from a HTTP "OK" response.
func NewTokenDeleteResultOK(body *TokenDeleteResponseBody) *tokenmanager.TokenDeleteResult {
	v := &tokenmanager.TokenDeleteResult{
		Code:    body.Code,
		Result:  body.Result,
		Message: body.Message,
	}

	return v
}

// ValidateTokenListResponseBody runs the validations defined on
// TokenListResponseBody
func ValidateTokenListResponseBody(body *TokenListResponseBody) (err error) {
	for _, e := range body.Result {
		if e != nil {
			if err2 := ValidateTokenItemResponseBody(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// ValidateTokenItemResponseBody runs the validations defined on
// TokenItemResponseBody
func ValidateTokenItemResponseBody(body *TokenItemResponseBody) (err error) {
	if body.ChainID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("chainId", "body"))
	}
	if body.Address == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("address", "body"))
	}
	if body.MarketName == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("marketName", "body"))
	}
	if body.Precision == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("precision", "body"))
	}
	if body.CoinType == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("coinType", "body"))
	}
	if body.Precision != nil {
		if *body.Precision < 6 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.precision", *body.Precision, 6, true))
		}
	}
	if body.Precision != nil {
		if *body.Precision > 18 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.precision", *body.Precision, 18, false))
		}
	}
	if body.CoinType != nil {
		if !(*body.CoinType == "stable_coin" || *body.CoinType == "coin") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.coinType", *body.CoinType, []interface{}{"stable_coin", "coin"}))
		}
	}
	return
}
